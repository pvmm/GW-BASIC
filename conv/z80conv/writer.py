#!/usr/bin/python
# Copyright (c) 2020 Leandro Pereira <leandro@hardinfo.org>
# Licensed under GPLv2.


class PasmoWriter:
    regmap = {
        'BX': 'HL', 'BH': 'H', 'BL': 'L',
        'DX': 'DE', 'DH': 'D', 'DL': 'E',
        'CX': 'BC', 'CH': 'B', 'CL': 'C',
        'SI': 'IY', 'DI': 'IX',
        'SP': 'SP',
        'AL': 'A',
        # FIXME: will need to spill/fill AX, AH, and AL using the Z80 prime
        # registers because the code uses AX as a 16-bit register extensively
    }

    def __init__(self, transformer):
        self.transformer = transformer

    def lines(self):
        for token in self.transformer.transform():
            generator = '_gen_' + token['type']
            if not hasattr(self, generator):
                raise SyntaxError("Don't know how to generate token of type %s (%s)" % (token['type'], token))

            line = getattr(self, generator)(token)
            if line is not None:
                yield line

    def _gen_comment(self, token):
        return '\n'.join('; %s' % line for line in token['value'].split('\n'))

    def _gen_directive_radix(self, token):
        return '\t.radix %s' % token['value']

    def _gen_assign(self, token):
        return '\t%s=%s' % (token['symbol'], token['value'])

    def _gen_cseg(self, token):
        return '; CSEG %s (%s)' % (token['name'], 'public' if token['public'] else 'local')

    def _gen_assume(self, token):
        return '; Assuming segment %s' % token['seg']

    def _gen_xlist(self, token):
        return None

    def _gen_list(self, token):
        return None

    def _gen_extern(self, token):
        extern = '\tEXTERN %s:%s' % (token['identifier'], token['attr'])
        return '%s ; %s' % (extern, token['comment']) if 'comment' in token and token['comment'] else extern

    def _gen_public(self, token):
        return '\tPUBLIC %s' % token['identifier']

    def _gen_sall(self, token):
        return None

    def _gen_include(self, token):
        return '\tinclude %s' % token['filename']

    def _gen_title(self, token):
        header = ';' * (len(token['value']) + 6)
        return '\n%s\n;; %s ;;\n%s\n' % (header, token['value'], header)

    def _gen_subtitle(self, token):
        return '\n;;; %s ;;;\n' % token['value']

    def _gen_label(self, token):
        return '%s:' % token['identifier']

    def _is_16bit_reg(self, reg):
        return isinstance(reg, str) and len(reg) == 2 and reg[1] == 'X' or reg == 'SI' or reg == 'DI' or reg == 'ES'

    def _gen_instruction_clc(self, token):
        return 'SCF\n\tCCF'

    def _gen_instruction_mov(self, token):
        # FIXME: not all operations are possible here; for instance, it's not
        # possible to perform LD DE, (HL), which is generated by this function
        # in some cases.  This would need to be a sereies of instructions to
        # load D and E separately as there's no LD DE, r16 instruction.
        operands = []
        for op in token['operands']:
            if op in self.regmap:
                operands.append(self.regmap[op])
            elif self._is_ptr_access_through_extern(op):
                if isinstance(op, str):
                    operands.append('(%s)' % op)
                elif len(op) == 3 and op[:2] == ('BYTE', 'PTR'):
                    operands.append('(%s)' % op[2])
                elif len(op) >= 2 and op[0] == 'OFFSET':
                    operands.append('(%s)' % ''.join(op[1:]))
                else:
                    operands.append('(%s)' % ''.join(op))
            elif self._is_ptr_read(op):
                op = op[2]
                if op[0] == '[' and op[1:-1] in self.regmap:
                    operands.append('(%s)' % self.regmap[op[1:-1]])
                elif op not in self.regmap:
                    operands.append('(%s)' % op)
            elif isinstance(op, str) and op[0] == '[':
                if op[1:-1] in self.regmap:
                    operands.append('(%s)' % self.regmap[op[1:-1]])
                else:
                    raise SyntaxError("Don't know how to generate this MOV op: %s" % op)
            elif isinstance(op, tuple):
                operands.append(' '.join(str(op) for op in op))
            else:
                operands.append(op)

        assert len(operands) == 2

        op0_is_index = operands[0] in {'IX', 'IY'}
        op1_is_index = operands[1] in {'IX', 'IY'}
        if op0_is_index != op1_is_index:
            z1, z2 = operands

            # Have to use undocumented instructions here.
            if op0_is_index:
                return 'LD %sH, %s\n\tLD %sL, %s' % (z1, z2[0], z1, z2[1])
            return 'LD %s, %sH\n\tLD %sL, %s' % (z1[0], z2, z1[1], z2)

        if all(self._is_16bit_reg(op) for op in token['operands']):
            return ('PUSH %s\n\t' +
                    'POP %s\n\t') % (operands[0], operands[1])

        return 'LD %s' % ', '.join(str(op) for op in operands)

    def _gen_instruction_add(self, token, z80='ADD'):
        assert len(token['operands']) == 2
        op1, op2 = token['operands']
        if op1 == 'AL' and self._is_ptr_read_through_bx(op2):
            return '%s A, (HL)' % z80
        if (op1, op2) == ('AL', 'AL'):
            return 'RLA'
        if op1 in self.regmap:
            if op2 in self.regmap:
                return '%s %s, %s' % (z80, self.regmap[op1], self.regmap[op2])
            return '%s %s, %s' % (z80, self.regmap[op1], ' '.join(str(op) for op in op2))
        if op1 == 'AX' and isinstance(op2, int):
            # FIXME: figure out what to do with usage of AX...
            return '; ADD AX, %dD' % op2
        raise SyntaxError("Don't know how to generate %s: %s, %s" % (z80, op1, op2))

    def _gen_instruction_adc(self, token):
        return self._gen_instruction_add(token, 'ADC')

    def _gen_instruction_inc(self, token):
        assert len(token['operands']) == 1
        op = token['operands'][0]
        if self._is_ptr_read_through_bx(op):
            return 'INC (HL)'
        if op == ('WORD', 'PTR', 0, '[BX]'):
            return ('PUSH IY\n\t' +
                    'PUSH BC\n\t' +
                    'LD IY, HL\n\t' +
                    'LD B, (IY+0)\n\t' +
                    'LD C, (IY+1)\n\t' +
                    'INC BC\n\t' +
                    'LD (IY+0), B\n\t' +
                    'LD (IY+1), C\n\t' +
                    'POP BC\n\t' +
                    'POP IY')
        if op in self.regmap:
            return 'INC %s' % self.regmap[op]
        raise SyntaxError("Could not generate INC %s" % str(op))

    def _is_low_imm8(self, op):
        return isinstance(op, tuple) and len(op) == 2 and op[0] == 'LOW' and isinstance(op[1], int)

    def _gen_instruction_cmp(self, token):
        assert len(token['operands']) == 2
        op1, op2 = token['operands']
        if op1 == 'AH':
            # FIXME: still don't know what to do about AH
            if isinstance(op2, tuple) and len(op2) == 2 and op2[0] == 'LOW' and isinstance(op2[1], int):
                return '; CMP AH, %dD' % op2[1]
        if token['operands'] == (('BYTE', 'PTR', 0, '[DI]'), 'AL'):
            # FIXME: implement this
            return '; CMP 0[DI], AL'
        if isinstance(op1, tuple) and len(op1) == 3 and op1[:2] == ('BYTE', 'PTR') and op1[2].endswith('[SI]'):
            if isinstance(op2, tuple) and len(op2) == 2 and op2[0] == 'LOW' and isinstance(op2[1], int):
                op2 = op2[1]
            elif not isinstance(op2, int):
                raise SyntaxError("Don't know how to generate CMP %s" % str(token))
            offset = op1[2][:-4]
            return ('PUSH BC\n\t' +
                    'LD B, A\n\t' +
                    'LD A, %dD\n\t' +
                    'CP (IY+%s)\n\t' +
                    'POP BC') % (op2, offset)
        if op1 == 'CH':
            if self._is_low_imm8(op2):
                op2 = op2[1]
            elif not isinstance(op2, int):
                raise SyntaxError("Can't generate CMP %s" % token)
            if 0 <= op2 <= 255 or -128 <= op2 <= 127:
                return ('PUSH BC\n\t' +
                        'PUSH HL\n\t' +
                        'LD H, A\n\t' +
                        'LD A, B\n\t' +
                        'CP %dD\n\t' +
                        'LD A, H\n\t' +
                        'POP HL\n\t' +
                        'POP BC') % op2
        if self._is_ptr_read_through_bx(op1):
            if self._is_low_imm8(op2):
                op2 = op2[1]
            elif not isinstance(op2, int):
                raise SyntaxError("Can't generate CMP %s" % token)
            return ('PUSH BC\n\t' +
                    'LD B, A\n\t' +
                    'LD A, %dD\n\t' +
                    'CP (HL)\n\t' +
                    'LD A, B\n\t' +
                    'POP BC') % op2
        if op1 == 'AL' and op2 in self.regmap:
            return 'CP %s' % self.regmap[op2]
        if op1 == 'AL':
            if isinstance(op2, tuple):
                if len(op2) >= 3 and op2[:2] == ('LOW', 'OFFSET'):
                    op2 = ''.join(str(op) for op in op2[2:])
                elif len(op2) >= 2 and op2[:1] == ('LOW',):
                    op2 = ''.join(str(op) for op in op2[1:])
                elif self._is_ptr_read_through_bx(op2):
                    op2 = '(HL)'
                elif len(op2) == 4 and op2[:2] == ('BYTE', 'PTR') and op2[3] in ('[DI]', '[SI]') and isinstance(op2[2], int):
                    op2 = '(%s+%d)' % (self.regmap[op2[3][1:-1]], op2[2])
                else:
                    raise SyntaxError("Don't know how to generate CMP AL, %s" % op2)
            return 'CP %s' % op2
        if op1 == 'DX' and isinstance(op2, int):
            return ('PUSH HL\n\t' +
                    'PUSH DE\n\t' +
                    'LD HL, %dD\n\t' +
                    'OR A\n\t' +
                    'SBC DE, HL\n\t' +
                    'ADD DE, HL\n\t' +
                    'POP DE\n\t' +
                    'POP HL') % op2
        if (op1, op2) == ('BX', 'DX'):
            return ('LD A, H\n\t' +
                    'SUB D\n\t' +
                    'RET NZ\n\t' +
                    'LD A, L\n\t' +
                    'SUB E')
        if op2 in self.regmap:
            reg = self.regmap[op2]
            if op1 == 'BX':
                return ('OR A\n\t' + \
                        'SBC HL, %s\n\t' + \
                        'ADD HL, %s') % (reg, reg)
            if op1 == '[BX]':
                return ('PUSH HL\n\t' + \
                        'LD HL, (HL)\n\t' + \
                        'OR A\n\t' + \
                        'SBC HL, %s\n\t' + \
                        'ADD HL, %s\n\t' + \
                        'POP HL') % (reg, reg)
        raise SyntaxError("Don't know how to generate CMP: %s" % token)

    def _gen_instruction_ja(self, token):
        assert len(token['operands']) == 1
        return ('JR NC, $+2\n\t' +
                'JP Z %s') % token['operands'][0]

    def _gen_instruction_jg(self, token):
        assert len(token['operands']) == 1
        return ('JR NZ, $+2\n\t' +
                'JP PE, %s') % token['operands'][0]

    def _gen_instruction_jmp(self, token):
        assert len(token['operands']) == 1
        op = token['operands'][0]
        if op == '[BX]':
            return 'JP (HL)'
        if isinstance(op, str):
            return 'JP %s' % op
        if len(op) == 2 and op[0] == 'SHORT':
            return 'JR %s' % op[1]
        raise SyntaxError("Unsupported JMP to %s" % op)

    def _gen_instruction_jne(self, token):
        return self._gen_instruction_jnz(token)

    def _gen_instruction_je(self, token):
        return self._gen_instruction_jz(token)

    def _gen_instruction_ret(self, token):
        assert len(token['operands']) == 0
        # FIXME: maybe look at the code to generate other RET variants?
        return 'RET'

    def _gen_instruction_retf(self, token):
        return self._gen_instruction_ret(token)

    def _gen_instruction_push(self, token):
        assert len(token['operands']) == 1
        op = token['operands'][0]
        if op == 'ES':
            return None
        if self._is_16bit_reg(op):
            if op != 'AX':
                return 'PUSH %s' % self.regmap[op]
            return 'PUSH AF'
        # FIXME: check if op is a dword label first!
        return 'PUSH HL\n\tLD HL, (%s)\n\tEX (SP), HL' % op

    def _gen_instruction_pop(self, token):
        assert len(token['operands']) == 1
        op = token['operands'][0]
        if op == 'ES':
            return None
        if self._is_16bit_reg(op):
            if op != 'AX':
                return 'POP %s' % self.regmap[op]
            return 'POP AF'
        raise SyntaxError("Only 16-bit registers can be popped (trying %s)" % op)

    def _gen_instruction_pushf(self, token):
        assert len(token['operands']) == 0
        return 'PUSH AF' # FIXME: Not really interested in saving A here... maybe store in a prime?

    def _gen_instruction_popf(self, token):
        assert len(token['operands']) == 0
        return 'POP AF' # FIXME: Not really interested in restoring A here... maybe store in a prime?

    def _gen_instruction_or(self, token):
        assert len(token['operands']) == 2
        op1, op2 = token['operands']
        if op1 == 'AL':
            if not self._is_16bit_reg(op2) and op2 in self.regmap:
                return 'OR %s' % self.regmap[op2]
            if self._is_ptr_read_through_bx(op2):
                return 'OR (HL)'
            if len(op2) == 2 and op2[0] == 'LOW':
                if isinstance(op2[1], int):
                    return 'OR %dD' % op2[1]
                return 'OR %s' % op2[1]
        if op1 == op2:
            return 'OR A' # NOP, but clear C/N/P/V flags
        if {op1, op2} == {'BX', 'DX'}:
            return ('PUSH A\n\t' +
                    'LD A, H\n\t' +
                    'OR D\n\t' +
                    'LD H, A\n\t' +
                    'LD A, L\n\t' +
                    'OR E\n\t' +
                    'LD L, A\n\t' +
                    'POP A')
        raise SyntaxError("Don't know how to generate an OR with these yet: %s, %s" % (op1, op2))

    def _gen_instruction_dec(self, token):
        assert len(token['operands']) == 1
        op = token['operands'][0]
        if self._is_ptr_read_through_bx(op):
            return 'DEC (HL)'
        if op in self.regmap:
            return 'DEC %s' % self.regmap[op]
        raise SyntaxError("Don't know how to generate DEC with arg %s" % op)

    def _gen_instruction_call(self, token):
        assert len(token['operands']) == 1
        op = token['operands'][0]
        if op.isalnum() or (op[0] == '$' and op[1:].isalnum()):
            return 'CALL %s' % op
        raise SyntaxError("Don't know how to generate CALL with arg %s" % op)

    def _gen_instruction_cond_jmp(self, cond, op, has_jr=False):
        is_short = isinstance(op, tuple) and len(op) == 2 and op[0] == 'SHORT'

        target = None
        if isinstance(op, str):
            target = op
        elif isinstance(op, tuple):
            if len(op) == 1:
                target = op[0]
            elif len(op) == 2:
                target = op[1]
        elif isinstance(op, int):
            if not(-128 <= op < 127 or 0 <= op <= 255):
                is_short = False
            target = op

        if target is None:
            raise NotImplementedError("Can't perform a conditional jump with target %s" % str(op))

        instruction = "JR" if has_jr and is_short else "JP"
        return "%s %s, %s" % (instruction, cond, target)

    def _gen_instruction_jz(self, token):
        assert len(token['operands']) == 1
        return self._gen_instruction_cond_jmp('Z', token['operands'][0], has_jr=True)

    def _gen_instruction_jnz(self, token):
        assert len(token['operands']) == 1
        return self._gen_instruction_cond_jmp('NZ', token['operands'][0], has_jr=True)

    def _gen_instruction_jae(self, token):
        assert len(token['operands']) == 1
        return self._gen_instruction_cond_jmp('NC', token['operands'][0], has_jr=True)

    def _gen_instruction_js(self, token):
        assert len(token['operands']) == 1
        return self._gen_instruction_cond_jmp('M', token['operands'][0])

    def _gen_instruction_jns(self, token):
        assert len(token['operands']) == 1
        return self._gen_instruction_cond_jmp('P', token['operands'][0])

    def _gen_instruction_jp(self, token):
        return self._gen_instruction_jns(token)

    def _gen_instruction_jb(self, token):
        assert len(token['operands']) == 1
        return self._gen_instruction_cond_jmp('C', token['operands'][0], has_jr=True)

    def _gen_instruction_jnae(self, token):
        return self._gen_instruction_jb(token)

    def _gen_instruction_jnb(self, token):
        return self._gen_instruction_jae(token)

    def _gen_instruction_stc(self, token):
        assert len(token['operands']) == 0
        return 'SCF'

    def _gen_instruction_lahf(self, token):
        raise NotImplementedError("This use of LAHF is not supported")

    def _gen_instruction_sahf(self, token):
        raise NotImplementedError("This use of SAHF is not supported")

    def _gen_instruction_cmc(self, token):
        assert len(token['operands']) == 0
        return 'CCF'

    def _gen_instruction_xchg(self, token):
        assert len(token['operands']) == 2
        op1, op2 = token['operands']
        if {op1, op2} == {'DX', 'BX'}:
            return 'EX DE, HL'
        if {op1, op2} == {'AL', 'AH'}:
            return '; FIXME: This is invalid Z80\n\tLD C\', A\n\tLD A, B\'\n\tLD B\', C\''
        if self._is_16bit_reg(op1) and self._is_16bit_reg(op2):
            push_pop_regs = {'AF', 'BC', 'DE', 'HL', 'IX', 'IY'}
            z1 = self.regmap[op1]
            z2 = self.regmap[op2]
            if z1 in push_pop_regs and z2 in push_pop_regs:
                return 'PUSH %s\n\tPUSH %s\n\tPOP %s\n\tPOP %s' % (z1, z2, z1, z2)
        raise SyntaxError("Don't know how to generate XCHG %s, %s" % (op1, op2))

    def _is_ptr_read_through_bx(self, op):
        return op[:2] == ('BYTE', 'PTR') and op[2:] in (('[BX]',), (0, '[BX]'))

    def _is_ptr_read(self, op):
        return isinstance(op, tuple) and len(op) == 3 and op[:2] == ('BYTE', 'PTR')

    def _is_ptr_access_through_extern(self, op):
        if isinstance(op, str):
            return self.transformer.extern(op) in ('WORD', 'BYTE')
        if isinstance(op, tuple):
            return any(self._is_ptr_access_through_extern(op) for op in op)
        return False

    def _gen_instruction_and(self, token):
        assert len(token['operands']) == 2
        op1, op2 = token['operands']
        if op1 == 'AL':
            if op2 in self.regmap:
                return 'AND %s' % self.regmap[op2]
            if self._is_ptr_read_through_bx(op2):
                return 'AND (HL)'
            return 'AND %s' % ' '.join(str(op) for op in op2)
        if {op1, op2} == {'BX', 'DX'}:
            return ('PUSH A\n\t' +
                    'LD A, H\n\t' +
                    'AND D\n\t' +
                    'LD H, A\n\t' +
                    'LD A, L\n\t' +
                    'AND E\n\t' +
                    'LD L, A\n\t' +
                    'POP A')
        raise SyntaxError("Don't know how to generate AND with ops %s, %s" % (op1, op2))

    def _gen_instruction_sub(self, token, z80='SUB'):
        assert len(token['operands']) == 2
        op1, op2 = token['operands']
        if op1 == 'AL':
            if op2 in self.regmap:
                return '%s %s' % (z80, self.regmap[op2])
            if self._is_ptr_read_through_bx(op2):
                return '%s (HL)' % z80
            if isinstance(op2, tuple) and len(op2) >= 2 and op2[0] == 'LOW':
                return '%s %s' % (z80, ' '.join(str(op) for op in op2[1:]))
        if op1 == 'CX':
            # FIXME: Implement this.
            return '; SUB CX, %s' % str(op2)
        if op1 == 'BX' and op2 == 'DX':
            # FIXME: Is SBC always the right choice here?
            return 'SBC HL, DE'
        if op1 == 'DL' and self._is_ptr_read(op2):
            return ('PUSH HL\n\t' +
                    'EX AF, AF\'\n\t' +
                    'LD A, E\n\t' +
                    'LD HL, %s\n\t' +
                    'SUB (HL)\n\t' +
                    'EX AF, AF\'\n\t' +
                    'POP HL') % op2[2]
        raise SyntaxError("Don't know how to generate %s with ops %s, %s" % (z80, op1, op2))

    def _gen_instruction_sbb(self, token):
        return self._gen_instruction_sub(token, 'SBC')

    def _gen_instruction_xor(self, token):
        assert len(token['operands']) == 2
        op1, op2 = token['operands']
        if op1 == 'AL':
            if op2 in self.regmap:
                return 'XOR %s' % self.regmap[op2]
            if isinstance(op2, tuple) and op2[0] == 'LOW' and isinstance(op2[1], int):
                op2 = op2[1]
            if isinstance(op2, int) and 0 <= op2 <= 255:
                return 'XOR %dD' % op2
        if (op1, op2) == ('AH', 'AH'):
            return '; FIXME: This is invalid Z80 code\n\tPUSH AF\n\tXOR A\n\tLD B\', 0\n\tPOP AF'
        if op1 == op2:
            # FIXME: what about the flags?
            if op1 in self.regmap:
                return 'LD %s, 0' % self.regmap[op1]
            elif op1 == 'AX':
                return '; FIXME: Invalid Z80 code\n\tLD AF, 0'
        if {op1, op2} == {'BX', 'DX'}:
            return ('EX AF, AF\'\n\t' +
                    'LD A, H\n\t' +
                    'XOR D\n\t' +
                    'LD H, A\n\t' +
                    'LD A, L\n\t' +
                    'XOR E\n\t' +
                    'LD L, A\n\t' +
                    'EX AF, AF\'')
        raise SyntaxError("Don't know how to generate XOR with ops %s, %s" % (op1, op2))

    def _gen_instruction_stosb(self, token):
        assert len(token['operands']) == 0
        return 'LD (IX), A'

    def _gen_instruction_xthl(self, token):
        assert len(token['operands']) == 0
        return 'EX (SP), HL'

    def _gen_instruction_ror(self, token):
        assert len(token['operands']) == 2
        op1, op2 = token['operands']
        if op2 == 1:
            if op1 == 'AL':
                return 'RRA'
            if not self._is_16bit_reg(op1) and op1 in self.regmap:
                return 'RR %s' % self.regmap[op]
            if op1 == '[BX]':
                return 'RR (HL)'
        raise SyntaxError("Don't know how to generate ROR with op %s, %s" % (op1, op2))

    def _gen_instruction_rcr(self, token):
        assert len(token['operands']) == 2
        op1, op2 = token['operands']
        if op2 == 1:
            if op1 == 'AL':
                return 'RRCA'
            if op1 in self.regmap:
                if self._is_16bit_reg(op1):
                    return 'PUSH HL\n\tADC HL, %s\n\tLD %s, HL\n\tPOP HL' % (self.regmap[op1], self.regmap[op1])
                else:
                    return 'RRC %s' % self.regmap[op]
            if op1 == '[BX]':
                return 'RRC (HL)'

        raise SyntaxError("Don't know how to generate RCR with op %s, %s" % (op1, op2))

    def _gen_instruction_rcl(self, token):
        assert len(token['operands']) == 2
        op1, op2 = token['operands']
        if op2 == 1:
            if op1 == 'AL':
                return 'RLCA'
            if op1 in self.regmap:
                if self._is_16bit_reg(op1):
                    return 'PUSH HL\n\tSBC HL, %s\n\tLD %s, HL\n\tPOP HL' % (self.regmap[op1], self.regmap[op1])
                else:
                    return 'RLC %s' % self.regmap[op]
            if op1 == '[BX]':
                return 'RLC (HL)'

        raise SyntaxError("Don't know how to generate RCL with op %s, %s" % (op1, op2))

    def _gen_instruction_rol(self, token):
        assert len(token['operands']) == 2
        op1, op2 = token['operands']
        if op2 == 1:
            if op1 == 'AL':
                return 'RLA'
            if not self._is_16bit_reg(op1) and op1 in self.regmap:
                return 'RL %s' % self.regmap[op]
            if op1 == '[BX]':
                return 'RL (HL)'
        raise SyntaxError("Don't know how to generate ROL with op %s, %s" % (op1, op2))

    def _gen_instruction_lodsb(self, token):
        return '; LODSB %s' % token

    def _gen_instruction_test(self, token):
        return '; TEST %s' % token

    def _gen_instruction_movi(self, token):
        return self._gen_instruction_mov(token)

    def _gen_instruction_neg(self, token):
        assert len(token['operands']) == 1
        op = token['operands'][0]
        if op == 'AL':
            return 'NEG'
        if self._is_16bit_reg(op):
            high, low = self.regmap[op]
            return ('EX AF, AF\'\n\t' +
                    'XOR A\n\t' +
                    'SUB %s\n\t' +
                    'LD %s, A\n\t' +
                    'SBC A, A\n\t' +
                    'SUB %s\n\t' +
                    'LD %s, A\n\t' +
                    'EX AF, AF\'') % (low, low, high, high)
        raise SyntaxError("Don't know how to generate NEG with op %s" % op)

    def _gen_instruction_shr(self, token):
        assert len(token['operands']) == 2
        op1, op2 = token['operands']
        if op2 == 1 and self._is_16bit_reg(op1):
            op1 = self.regmap[op1]
            return 'SRL %s\n\tRR %s' % (op1[0], op1[1])
        raise SyntaxError("Don't know how to generate SHR %s, %s" % (op1, op2))

    def _gen_instruction_not(self, token):
        assert len(token['operands']) == 1
        op = token['operands'][0]
        if op == 'AL':
            return 'CPL'
        if op == 'BX':
            return ('EX AF, AF\'\n\t' +
                    'LD A, H\n\t' +
                    'CPL\n\t' +
                    'LD H, A\n\t' +
                    'LD A, L\n\t' +
                    'CPL\n\t' +
                    'LD L, A\n\t' +
                    'EX AF, AF\'')
        raise SyntaxError("Don't know how to generate NOT %s" % op)

    def _gen_instruction_mul(self, token):
        assert len(token['operands']) == 1
        op = token['operands'][0]
        # http://cpctech.cpc-live.com/docs/mult.html has a nice algorithm
        # for 16-bit multiplication
        if op == 'DX':
            return '; MUL DX'
        raise SyntaxError("Don't know how to generate MUL %s" % op)

    def _gen_instruction_in(self, token):
        assert len(token['operands']) == 2
        op1, op2 = token['operands']
        if op1 == 'AL' and op2 == 'DX':
            # This is not exactly equivalent, because ports in Z80 are 8-bit and in 8086
            # they're 16-bit... so we just take the lower byte.
            return ('PUSH BC\n\t' +
                    'LD BC, DE\n\t' +
                    'IN A, (C)\n\t' +
                    'POP BC')
        raise SyntaxError("Don't know how to generate IN %s, %s" % (op1, op2))

    def _gen_instruction_out(self, token):
        assert len(token['operands']) == 2
        op1, op2 = token['operands']
        if op1 == 'DX' and op2 == 'AL':
            # This is not exactly equivalent, because ports in Z80 are 8-bit and in 8086
            # they're 16-bit... so we just take the lower byte.
            return ('PUSH BC\n\t' +
                    'LD BC, DE\n\t' +
                    'OUT (C), A\n\t' +
                    'POP BC')
        raise SyntaxError("Don't know how to generate IN %s, %s" % (op1, op2))

    def _gen_instruction_int(self, token):
        assert len(token['operands']) == 1
        op = token['operands'][0]
        # FIXME: what to do here?
        return '; INT %dD' % op

    def _gen_instruction_ret_jz(self, token):
        return 'RET Z'

    def _gen_instruction_ret_jnz(self, token):
        return 'RET NZ'

    def _gen_instruction_ret_jnb(self, token):
        return 'RET NC'

    def _gen_instruction_ret_js(self, token):
        return 'RET M'

    def _gen_instruction_ret_jb(self, token):
        return 'RET C'

    def _gen_instruction_ret_jae(self, token):
        return self._gen_instruction_ret_jnb(token)

    def _gen_instruction_ret_jnae(self, token):
        return self._gen_instruction_ret_jb(token)

    def _gen_instruction_ret_jns(self, token):
        return self._gen_instruction_ret_js(token)

    def _gen_instruction_ret_jnae(self, token):
        return self._gen_instruction_ret_jb(token)

    def _gen_instruction_jmp_ae(self, token):
        return self._gen_instruction_jae(token)

    def _gen_instruction_jmp_s(self, token):
        return self._gen_instruction_js(token)

    def _gen_instruction_jmp_nae(self, token):
        return self._gen_instruction_jnae(token)

    def _gen_instruction_jmp_z(self, token):
        return self._gen_instruction_jz(token)

    def _gen_instruction_jmp_nz(self, token):
        return self._gen_instruction_jnz(token)

    def _gen_instruction_jmp_ns(self, token):
        return self._gen_instruction_jns(token)

    def _gen_instruction_std(self, token):
        # FIXME: what to do here?
        return '; STD'

    def _gen_instruction_cld(self, token):
        # FIXME: what to do here?
        return '; CLD'

    def _gen_instruction_cli(self, token):
        return 'DI'

    def _gen_instruction_sti(self, token):
        return 'EI'

    def _gen_instruction_repe_scasb(self, token):
        # FIXME: what to do here?
        return '; REPE SCASB'

    def _gen_instruction_savepsw(self, token):
        if token['operands'] == ('stack',):
            return 'PUSH AF'
        if token['operands'] == ('reg',):
            return 'EX AF, AF\''
        raise SyntaxError("Internal error: operands for savepsw are invalid: %s" % str(token))

    def _gen_instruction_restorepsw(self, token):
        if token['operands'] == ('stack',):
            return 'POP AF'
        if token['operands'] == ('reg',):
            return 'EX AF, AF\''
        raise SyntaxError("Internal error: operands for savepsw are invalid: %s" % str(token))

    def _gen_instruction_djnz(self, token):
        return 'DJNZ %s' % token['operands'][0][-1]

    def _gen_instruction_mul16by8(self, token):
        return '; MUL 16-by-8 %s' % str(token['operands'])

    def _gen_instruction_call_z(self, token):
        return 'CALL Z, %s' % token['operands'][0]

    def _gen_instruction_call_nz(self, token):
        return 'CALL NZ, %s' % token['operands'][0]

    def _gen_instruction_call_b(self, token):
        return 'CALL C, %s' % token['operands'][0]

    def _gen_instruction_call_nc(self, token):
        return 'CALL NC, %s' % token['operands'][0]

    def _gen_instruction_call_ae(self, token):
        return self._gen_instruction_call_nc(token)

    def _gen_instruction(self, token):
        op = token['op']
        instr = getattr(self, '_gen_instruction_' + op.lower())(token)
        return '\t%s\t\t; %s' % (instr, token['comment']) if token['comment'] else '\t' + instr

    def _gen_macro_call(self, token):
        args = []
        for arg_tuple in token['args']:
            for arg in arg_tuple:
                if arg['type'] in ('token', 'number'):
                    args.append(arg['value'])
                else:
                    raise SyntaxError("Unexpected type for macro argument: %s" % arg['type'])
        line = '\t%s %s' % (token['identifier'], ', '.join(args))
        return '%s ; %s' % (line, token['comment']) if token['comment'] else line

    def _gen_org(self, token):
        return '\torg %s' % token['value']

    def _gen_db(self, token):
        bytes = token['bytes'][0]
        if isinstance(bytes, tuple):
            if bytes[0] == 'offset':
                if isinstance(bytes[1], int):
                    return "\tDB %dD" % bytes[1]
                return "\tDB %s" % bytes[1]
        if isinstance(bytes, int):
            return "\tDB %dD" % bytes
        return '\tDB %s' % bytes

    def _gen_dw(self, token):
        return '\tdw %s' % ', '.join(str(b) for b in token['bytes'])

    def _gen_label_def(self, token):
        return '%s: ; %s' % (token['identifier'], ' '.join(token['attrs']))

    def _gen_equ(self, token):
        equ = '\t%s equ %s' % (token['identifier'], ' '.join(token['attrs']))
        return '%s ; %s' % (equ, token['comment']) if token['comment'] else equ

    def _gen_if(self, token):
        return 'IF %s' % ' '.join(token['cond'])

    def _gen_ifdef(self, token):
        return 'IFDEF %s' % ' '.join(token['cond'])

    def _gen_end_if(self, token):
        return 'ENDIF'

    def _gen_macro(self, token):
        macro = '%s MACRO %s' % (token['identifier'], ', '.join(token['args']))
        return '%s ; %s' % (macro, token['comment']) if token['comment'] else macro

    def _gen_end_macro(self, token):
        return 'ENDM'

    def _gen_end_forc(self, token):
        return 'ENDM'

    def _gen_echo(self, token):
        return '\t.WARNING %s' % ' '.join(token['value'] for token in token['msg'])

    def _gen_forc(self, token):
        assert len(token['args']) == 2
        op1, op2 = token['args']
        return '\tIRP %s, %s' % (op1['value'], op2['value'])

    def _gen_ifdif(self, token):
        assert len(token['ops']) == 2
        op1, op2 = token['ops']
        return '\tIF %s != %s' % (op1, op2)

    def _gen_ife(self, token):
        return '\tIF (%s) = 0' % ''.join(str(cond) for cond in token['cond'])

    def _gen_else(self, token):
        return '\tELSE'

    def _gen_rept(self, token):
        return 'REPT %s' % token['count']['value']

    def _gen_end_rept(self, token):
        return 'ENDM'
